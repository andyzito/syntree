<div class="document" id="class-analysis-of-use-case-1-creating-a-syntax-tree"><h1 class="title">Class Analysis of Use Case #1: Creating a Syntax Tree</h1><p class="historical_warning">This is a historical document (from November 2016). It may have some out of date terms or other idiosyncrasies compared to updated documents like Use Cases or the Class Diagram.</p><div class="section" id="nouns"><h1>Nouns</h1><ul class="simple"><li>GUI</li><li>User</li><li>Node<ul><li>Root node</li><li>Child node</li><li>Sibling node</li></ul></li><li>Textbox</li><li>Border</li><li>Syntax tree</li></ul></div><div class="section" id="analysis"><h1>Analysis</h1><p>I have established that Node is probably the most important class here. A syntax tree is composed of nodes and an overwhelming majority of the operation involve interactions between Nodes. The noun ‘textbox’ is referring to the visual representation of a node in the GUI, so we can encapsulate that within the Node class. Similarly with the border or highlight. As to the various types of nodes, these are best represented as Node instances with different properties and relations to one another.</p><p>The second most important class here will be the (syntax) Tree class. It will serve as a way to hold the nodes as a mapped collection rather than what amounts to a linked list. It will also serve to hold methods that operate on large numbers of nodes in a non-transversal way, such as retrieving nodes at a certain offset from the root. Furthermore, it can carry state variables such as the currently selected node.</p><p>The user is the user, and within the syntax tree drawer itself there is no reason to represent them in code (this will change when it comes to the website itself).</p><p>The GUI itself can be thought of as several components, specifically the SVG workspace and the elements within it, the Snap.svg javascript library which allows for easier SVG manipulation, and the various functions of jQuery which allow for other visual manipulations. It remains to be seen whether having these various visual tools encapsulated in a single class would be useful. As of now they exist as an implicit layer in between any underlying classes and the output the user sees. Of particular concern are event listeners, which can also be thought of as part of the GUI, but have no real home in the code as of now.</p></div></div><div class="document" id="class-analysis-of-tier-2-use-cases-4-and-5"><h1 class="title">Class Analysis of Tier 2 Use Cases (#4 and #5)</h1><p class="historical_warning">This is a historical document, from November 2016. It may have some out of date terms or other idiosyncrasies compared to updated documents like Use Cases or the Class Diagram.</p><div class="section" id="nouns-from-tier-2-use-cases-that-do-not-appear-in-tier-1"><h1>Nouns from Tier 2 Use Cases (that do not appear in Tier 1)</h1><ul class="simple"><li>Button</li><li>Alert- Message- Button</li><li>File dialog</li><li>File</li><li>Menu- Dropdown menu</li><li>Dialog</li><li>File type</li><li>Base node</li><li>Option(s)</li><li>“Shadow” tree</li></ul></div><div class="section" id="analysis"><h1>Analysis</h1><p>Several of these are clearly graphical elements (button, alert) that really don’t have a clear place to reside in the class diagram as it is. There are several graphical elements so far, existing as properties of Node and Workspace and Branch. The issue is further complicated by the fact that things like buttons may be implemented as HTML elements rather than SVG elements. It is likely that Button would be a good class, and possibly Alert as well (although this might also be a method of Workspace). In any case, it is clear that some restructuring will be needed to accommodate the multiplication of graphical elements.</p><p>“File dialog” should not need to be represented in our custom code, as it is built into the browser and we are just accessing it. Custom dialogs, on the other hand, (see exporting use cases) will likely need their own class. This would suggest that having Alerts be a method of Workspace is not the right way to go, and instead we might want to lean towards something like an overarching Modal class (which has child classes Alert and Dialog and etc.).</p><p>Menus are yet another graphical element that needs to be handled. Perhaps we need to simply make a Graphic class, from which all graphical elements that need to be represented in code can use. At the very least, such a class for controls (as opposed to pieces of the tree) might be a good idea.</p><p>The “shadow” tree is particularly difficult. At first it might be tempting to think of it as a method of Tree, but the fact is that it can be called on subtrees as well and how are we to deal with that? It is obviously ridiculous to make every subtree a Tree with it’s own shadow method (consider the number of possible subtrees for even a moderately sized Tree). Potentially this shadow tree could be categorized as a graphical interaction and thus handled by Workspace or another graphical management class.</p></div></div>